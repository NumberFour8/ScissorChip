#include "msp430.h"
NAME msp_mp

; Reduces the number A modulo 2^255-19
; A is given by R12 and must be 512-bits (64 bytes) long in little-endian
PUBLIC mp_mod25519
RSEG CODE

mp_mod25519

  MOV R12,R4
  MOV R12,R5
  MOV #3,R7     ; In the worst-case scenario we need to reduce 3 times
  
  SUB #2,R4     ; Starting point
  ADD #32,R5    ; Upper pointer bound (beyond the MS word, additions by 2)
  
reduce_limbs
    INCD R4
    CMP R4,R5
    JZ limbs_done       ; If terminal address has been reached, go to round_done
    
    MOV 0x0(R4),&MPY    ; LSB of LS half
    MOV #0x01,&OP2      ; 1
    
    MOV 0x20(R4),&MAC   ; LSB of MS half 
    MOV #0x26,&OP2      ; 38
    
    MOV RESLO,0x0(R4)   ; Save S to LSB of LS half
    ADD RESHI,0x2(R4)   ; Add the carry to the second-LSB of the LS half
    
    CLR 0x20(R4)        ; We don't need this MS limb anymore
    JNC reduce_limbs    ; If no carry was created, proceed with the next digit
    
    MOV R4,R6           
    ADD #4,R6           ; Set R6 as the address after the processed words  
    
carry_prop              ; Now we need to propagate the carry
    SETC                ; Restore the carry bit
    ADC 0x0(R6)         ; Add the carry bit to where R6 points
    JNC reduce_limbs    ; If no more carry, step out
    INCD R6             ; Increment R6 by 2 
    JMP carry_prop      ; Otherwise, continue propagating
   
limbs_done  
    MOV R12,R4
    MOV R12,R5       
    ADD #2,R5           ; We lower the terminal address as we don't need to go further than 1 word  
    SUB #2,R4           ; Rewind R4
    DEC R7
    JNZ reduce_limbs    ; If we didn't reduce 3 times, continue  
    
RETA

PUBLIC mp_condsub
RSEG CODE

; Subtracts 2^255-19 from the number pointed by R12 if the R4 == 1
; otherwise subtracts nothing.

mp_condsub

    PUSH.W R5 
    PUSH.W R6
    PUSH.W R10  ; Save other used registers
    
    ; Need to precompute FFFF or 0 to R4
    MOV R4,R5
    CLR R4
    SUB R5,R4   ; R4 == 0 ? R4 = 0 : R4 = FFFF 

    ; Now subtract the least significant limb
    MOV #0xFFED,R5
    AND R4,R5
    CLRC
    SUB R5,0x0(R12)
    SBC 0x2(R12) ; If nothing was subtracted, there is no carry        

    MOV R12,R10
    MOV R12,R6
    ADD #2,R10
    ADD #30,R6
insub
    MOV #0xFFFF,R5
    AND R4,R5
    CLRC
    SUB R5,0x0(R10)     ; Subtract from the inner limbs
    SBC 0x2(R10)        
    INCD R10
    CMP R6,R10
    JNZ insub

    ; Finally subtract the most significant limb
    MOV #0x7FFF,R5      
    AND R4,R5
    CLRC
    SUB R5,0x1e(R12)

    POP.W R5    ; Restore the registers
    POP.W R6
    POP.W R10
    
RETA

PUBLIC mp_condadd
RSEG CODE

; Adds 2^255-19 from the number pointed by R12 if the R4 == 1
; otherwise adds nothing.

mp_condadd

    PUSH.W R5 
    PUSH.W R6
    PUSH.W R10  ; Save other used registers
    
    ; Need to precompute FFFF or 0 to R4
    MOV R4,R5
    CLR R4
    SUB R5,R4   ; R4 == 0 ? R4 = 0 : R4 = FFFF 

    ; Now subtract the least significant limb
    MOV #0xFFED,R5
    AND R4,R5
    CLRC
    ADD R5,0x0(R12)
    ADC 0x2(R12) ; If nothing was added, there is no carry        

    MOV R12,R10
    MOV R12,R6
    ADD #2,R10
    ADD #30,R6
inadd
    MOV #0xFFFF,R5
    AND R4,R5
    ADD R5,0x0(R10)     ; Add to the inner limbs
    ADC 0x2(R10)        
    INCD R10
    CMP R6,R10
    JNZ insub

    ; Finally add the most significant limb
    MOV #0x7FFF,R5      
    AND R4,R5
    ADD R5,0x1e(R12)

    POP.W R5    ; Restore the registers
    POP.W R6
    POP.W R10
    
RETA

PUBLIC mp_freeze
RSEG CODE

; Conditionally subtract 2^255-19 from the 255-bit number pointed by R12

mp_freeze

; -- The following code does: R4 = (R12 > 2^255-19)
    MOV #0x7FFF,R4    
    XOR 0x1e(R12),R4    
    SUB #1,R4
    AND #1,R4       ; Set if the first limb is equal to 7FFF
    
    MOV R12,R10
    MOV R12,R6
    ADD #28,R10
    ADD #2,R6       ; R6 contains the stop address, the 2nd LS word
compr
    MOV #0xFFFF,R5      
    XOR 0x0(R10),R5
    SUB #1,R5
    AND #1,R5    
    AND R5,R4       ; Set if any inner limbs are equal to FFFF
    DECD R10
    CMP R6,R10
    JNZ compr

    MOV #0xFFED,R5
    SUB 0x0(R12),R5
    AND #1,R5
    XOR #1,R5
    AND R5,R4       ; Set if the last limb is greater or equal to FFED
 
; -- 
    CALLA #mp_condsub

RETA


PUBLIC mp_cprop
RSEG CODE

; Propagates carry from address pointed by R10+2 until address given by R11 is reached (inclusive)
mp_cprop

  PUSH.W R8     ; Save R8
  PUSH.W R9     ; Save R9
  
  CLR R9        ; Clear R9
  ADC R9        ; Put the carry to R9
  MOV R10,R8    ; Put R10 to R8
cpg
  CMP R8,R11     ; Check if the last word was already processed
  JZ cpd         ; If yes, quit
  INCD R8        ; Move onto the next word
  
  ADD R9,0x0(R8) ; Add the carry to what R10 points to
  CLR R9         ; Clear R9
  ADC R9         ; Put the carry to R9
  JMP cpg
  
cpd
  TST R9        ; Check if there's still some carry in R9
  CLRC          ; Clear the carry flag after TST
  JZ cfin       ; If not just goto finish
  SETC          ; If yes, set the carry bit to allow further manual propagation
  
cfin
  POP.W R9      ; Restore R9
  POP.W R8      ; Restore R8
  
RETA

PUBLIC mp_monrep25519
RSEG CODE

; Converts the given value to the Montgomery representation modulo 2^255-19
; r = 2^256
mp_monrep25519

  CLR R7
  MOV R12,R10
  MOV R12,R11
  ADD #31,R11   ; Set R11 to the last word
  
repmul
  CMP R10,R11   ; Check if we already processed the last word
  JZ repfin     ; If we did, finish multiplying

  MOV 0x0(R10),&MPY  ; Initialize the accumulator to what's at R10
  MOV #1,&OP2

  MOV 0x0(R10),&MAC  ; Multiply R10 by 38 and accumulate
  MOV #38,&OP2
  
  MOV RESLO,0x0(R10) ; Set the LS word to the lower word of the result 
  INCD R10           ; Move R10 to the next word
  ADD RESHI,0x0(R10) ; The carry in the higher word has to be added 
  CALLA #mp_cprop    ; Propagate the carry (starts from 4th word)
  ADC R7             ; Propagate possible overflow carry to R7
  JMP repmul
  
repfin    
  MOV 0x0(R12),&MPY    ; Put the LS word in the accumulator
  MOV #1,&OP2       
  
  MOV R7,&MAC          ; The overflow carry is in R7 
  MOV #0x26,&OP2       ; 38
    
  MOV RESLO,0x0(R12)   ; Save S to LSB of LS half
  
  MOV R12,R10
  INCD R10             ; Now we start propagating from R12+4 (mp_cprop adds 2) 
  
  ADD RESHI,0x0(R12)   ; Add the carry to second word and propagate
  CALLA #mp_cprop
  CALLA #mp_freeze
  
RETA

PUBLIC mp_mulmod  
RSEG CODE       

; Performs modular multiplication of A and B which are both in Montgomery representation.
; The reduction is done modulo 2^255-19
; A is pointed by R12, B is pointed by R13.
; The result T has to be pointed by R14

mp_mulmod
  ; Finely Integrated Operand Scanning
  ; t[s] = R10, t[s+1] = R11, m = R4
  ; -------------------------------------- 
  CLR R10
  CLR R11

  ; For loop i = 0 .. s-1
  MOV R13,R7  ; Traverses B
  ADD #32,R7  ; Excluding sth word
outer_for

  ; (C,S) = t[0] + a[0]*b[i]
  MOV 0x0(R14),&MPY  ; t[0]
  MOV #1,&OP2        ; 1
  
  MOV 0x0(R12),&MAC  ; a[0]
  MOV 0x0(R13),&OP2  ; b[i]
  
  MOV RESLO,R5       ; Store S in R5
   
  ; ADD(t[1],C)
  PUSH.W R10 
  PUSH.W R11  ; Save R10 and R11
  
  MOV R14,R10        ; Put R14 to R10 which points to T
  INCD R10           ; Start adding carry after t[1]
  MOV R14,R11        
  ADD #30,R11        ; until (s-1)th word inclusive  
  ADD RESHI,0x0(R10)
  CALLA #mp_cprop    ; Propagate the carry (start at t[2])
  
  POP.W R11
  POP.W R10   ; Restore R10 and R11
  
  ADC R10     ; Propagate carry further to t[s]
  ADC R11     ; and to t[s+1]
  
  ; m = S*n'[0] mod 2^16
  MOV R5,&MPY        ; S
  MOV #0xCA1B,&OP2   ; n'[0]
  MOV RESLO,R4       ; Store m to R4
  
  ; (C,S) = S + m*n[0]
  MOV R5,&MPY           ; S
  MOV #1,&OP2           ; 1
  MOV R4,&MAC           ; m
  MOV #0xFFED,&OP2      ; n[0]
  
  ; For j = 1 .. s-2, last iteration is unrolled
  MOV R12,R8 
  INCD R8      ; a[j]
  MOV R12,R9    
  ADD #30,R9   ; a[s-1]
  MOV R14,R5
  INCD R5      ; t[j]
  MOV R14,R6   
  ADD #30,R6   ; t[s-1]
inner_for       
    
    MOV RESHI,R15
    
    ; (C,S) = t[j] + a[j]*b[i] + C
    MOV 0x0(R5),&MPY ; t[j]
    MOV #1,&OP2      ; 1
    
    MOV R15,&MAC   ; C
    MOV #1,&OP2      ; 1
    
    MOV 0x0(R8),&MAC  ; a[j]
    MOV 0x0(R13),&OP2 ; b[i] 
    
    ; ADD(t[j+1],C)
    PUSH.W R10
    PUSH.W R11  ; Save R10 and R11
    
    MOV R5,R10
    MOV R6,R11
    INCD R10
    ADD RESHI,0x0(R10)
    CALLA #mp_cprop  
    
    POP.W R11   
    POP.W R10   ; Restore R10 and R11
    
    ADC R10     ; Propagate carry further to t[s]
    ADC R11     ; and to t[s+1]
    
    ; (C,S) = S + m*n[j]
    MOV RESLO,&MPY      ; S
    MOV #1,&OP2         ; 1
    
    MOV R4,&MAC         ; m
    MOV #0xFFFF,&OP2    ; n[j] = 0xFFFF for j = 1 .. s-2
    
    ; t[j-1] = S
    MOV RESLO,-2(R5)
    
    INCD R8  ; Advance to a[++j]
    INCD R5  ; Advance to t[++j]
    CMP R8,R9 ; j = s-1 halts the loop
    JNZ inner_for
    
  ; The last iteration of the inner for is unrolled
  MOV RESHI,R15  
    
  ; (C,S) = t[s-1] + a[s-1]*b[i] + C
  MOV 0x0(R5),&MPY ; t[s-1]
  MOV #1,&OP2      ; 1
    
  MOV R15,&MAC   ; C
  MOV #1,&OP2      ; 1
    
  MOV 0x0(R8),&MAC  ; a[s-1]
  MOV 0x0(R13),&OP2 ; b[i] 
    
  ; ADD(t[s],C)
  ADD RESHI,R10
  ADC R11    ; Propagate carry to t[s+1]
    
  ; (C,S) = S + m*n[s-1]
  MOV RESLO,&MPY
  MOV #1,&OP2
    
  MOV R4,&MAC
  MOV #0x7FFF,&OP2
    
  ; t[s-2] = S
  MOV RESLO,-2(R5)
  
  ; Now the final post-processing
    
  ; (C,S) = t[s] + C
  MOV R10,R4      ; m is not needed anymore
  ADD RESHI,R4    ; Store S in R4
    
  MOV R4,0x0(R5)  ; t[s-1] = S
  MOV R11,R10     ; Store t[s+1] to t[s]
  ADC R10         ; t[s] = t[s+1] + C
  CLR R11         ; t[s+1] = 0
    
  INCD R13
  CMP R7,R13       ; Check if B traversal is still less than s
  JNZ outer_for
  
  MOV R14,R12      ; Move R12 to the result in R14
  CALLA #mp_freeze ; Conditionally subtract 2^255-19 in constant time
  
RETA


; Adds two 256-bit numbers A and B and stores the result in A.
; B is pointed by R13, A is pointed by R12
PUBLIC mp_add   
RSEG CODE       

mp_add

    ADD  @R13+,0x0(R12) 
    ADDC @R13+,0x2(R12)
    ADDC @R13+,0x4(R12)
    ADDC @R13+,0x6(R12)
    ADDC @R13+,0x8(R12)
    ADDC @R13+,0xa(R12)
    ADDC @R13+,0xc(R12)
    ADDC @R13+,0xe(R12)
    ADDC @R13+,0x10(R12)
    ADDC @R13+,0x12(R12)
    ADDC @R13+,0x14(R12)
    ADDC @R13+,0x16(R12)
    ADDC @R13+,0x18(R12)
    ADDC @R13+,0x1a(R12)
    ADDC @R13+,0x1c(R12)
    ADDC @R13+,0x1e(R12)
    
    PUSH.W R4
    CLR R4
    MOV SR,R4           ; Save the carry flag
   
    
 
    POP.W R4
RETA
      
; Subtracts B from A where A and B are 256-bit numbers and stores the result in A.
; B is pointed by R13, A is pointed by R12
PUBLIC mp_sub   
RSEG CODE       

mp_sub
    
    PUSH.W R4
    PUSH.W R5
    PUSH.W R6
  
    MOV R12,R6
    MOV R13,R5
    ADD #28,R6
    ADD #28,R5

    SUB  0x1e(R13),0x1e(R12) ; No need to CLRC in every step
csub
    SUBC 0x0(R5),0x0(R6)
    MOV SR,R4
    DECD R5
    DECD R6
    CMP R6,R12
    JNZ csub
   
     ; Now check if there was some more carry
    AND #4,R4   
    RLAM.W #2,R4 ; 1 if carry, 0 if no carry
    CALLA #mp_condadd
    
    POP.W R4
    POP.W R5
    POP.W R6
RETA
  
END
