#include "msp430.h"
NAME msp_mp

; Reduces the number A modulo 2^255-19
; A is given by R12 and must be 512-bits (64 bytes) long in little-endian
PUBLIC mp_mod25519
RSEG CODE

mp_mod25519

  MOV R12,R4
  MOV R12,R5
  
  SUB #2,R4     ; Starting point
  ADD #32,R5    ; Upper pointer bound (beyond the MS word, additions by 2)
  
reduce
    INCD R4
    CMP R4,R5
    JZ round_done       ; If terminal address has been reached, go to round_done
    
    MOV 0x0(R4),&MPY    ; LSB of LS half
    MOV #0x01,&OP2      ; 1
    
    MOV 0x20(R4),&MAC   ; LSB of MS half 
    MOV #0x26,&OP2      ; 38
    
    MOV RESLO,0x0(R4)   ; Save S to LSB of LS half
    ADD RESHI,0x2(R4)   ; Add the carry to the second-LSB of the LS half
    
    CLR 0x20(R4)
    JNC reduce          ; If no carry was created, proceed with the next digit
    
    MOV R4,R6           
    ADD #4,R6           ; Set R6 as the address after the processed words  
    
carry_prop ; Now we need to propagate the carry
      SETC          ; Restore the carry bit
      ADC 0x0(R6)   ; Add the carry bit to where R6 points
      JNC reduce    ; If no more carry, step out
      INCD R6       ; Increment R6 by 2 
 JMP carry_prop    ; Otherwise, continue propagating
   
round_done  
     MOV 0x20(R12),R6 ; There cannot be more carry, even after the first reduction
     MOV R12,R4
     MOV R12,R5       
     ADD #2,R5      ; We lower the terminal address as we don't need to go further than 1 word  
     SUB #2,R4        ; Rewind R4
     CMP #0,R6
     JNZ reduce       ; If R6 is non zero, another reduction round is needed
  
 MOV #2,R4
 
; Now we try to subtract 2^255-19 twice

reduce_sub
    SUB #0x00ED,0x0(R12)
    SUBC #0xFFFF,0x2(R12)
    SUBC #0xFFFF,0x4(R12)
    SUBC #0xFFFF,0x6(R12)
    SUBC #0xFFFF,0x8(R12)
    SUBC #0xFFFF,0xa(R12)
    SUBC #0xFFFF,0xc(R12)
    SUBC #0xFFFF,0xe(R12)
    SUBC #0xFFFF,0xe(R12)
    SUBC #0xFFFF,0x10(R12)
    SUBC #0xFFFF,0x12(R12)
    SUBC #0xFFFF,0x14(R12)
    SUBC #0xFFFF,0x16(R12)
    SUBC #0xFFFF,0x18(R12)
    SUBC #0xFFFF,0x1a(R12)
    SUBC #0xFFFF,0x1c(R12)
    SUBC #0x7FFF,0x1e(R12) 
    JN reduce_add
    DEC R4
    JZ reduce_finish
  JMP reduce_sub
  
reduce_add
    ADD #0x00ED,0x0(R12)
    ADDC #0xFFFF,0x2(R12)
    ADDC #0xFFFF,0x4(R12)
    ADDC #0xFFFF,0x6(R12)
    ADDC #0xFFFF,0x8(R12)
    ADDC #0xFFFF,0xa(R12)
    ADDC #0xFFFF,0xc(R12)
    ADDC #0xFFFF,0xe(R12)
    ADDC #0xFFFF,0xe(R12)
    ADDC #0xFFFF,0x10(R12)
    ADDC #0xFFFF,0x12(R12)
    ADDC #0xFFFF,0x14(R12)
    ADDC #0xFFFF,0x16(R12)
    ADDC #0xFFFF,0x18(R12)
    ADDC #0xFFFF,0x1a(R12)
    ADDC #0xFFFF,0x1c(R12)
    ADDC #0x7FFF,0x1e(R12) 
   
reduce_finish  
    
RETA


PUBLIC mp_addc16
RSEG CODE

; Add 16-bit value V to A and propagate the carry
; A is pointed by R12, V by R13

mp_addc16
    ADD 0x0(R12),0x0(R13) ; Add R13 to R12
    JNC _addc_fin         ; If not carry, exit

    MOV R2,R12            ; Copy the address 
    ADD #30,R2            ; Set the upper bound (???)
_propagate
     INCD R12             ; Increment offset by 2
     CMP R12,R2           ; Compare with the upper bound
     JEQ _addc_fin        ; If reached, exit
     CLRC                 ; Clear the carry flag
     INC 0x0(R12)         ; Increment offset value by 1
   JC _propagate          ; If there's carry, propagate

_addc_fin ; Finish

RETA


; B is pointed by R13, A is pointed by R12
; Result C is pointed by R14
PUBLIC mp_mulmod  
RSEG CODE       

mp_mulmod
  ; Finely Integrated Operand Scanning
  ; t[s] = R2, t[s+1] = R3, m = R4
  ; -------------------------------------- 

  ; For loop i = 0 .. s-1
  
  ; (C,S) = a[0]*b[i] + t[0]
  MOV #0x01,&MAC
  MOV 0x0(R14),OP2
  
  MOV 0x0(R12),&MAC
  MOV 0x0(R13),OP2
  
  ; t[1] += C
  INC R14
  CALLA mp_addc16
  DEC R14
  
  ; m = S*n[0]
  MOV RESLO,&MPY
  MOV #1234,OP2
    
RETA


; Adds two 256-bit numbers A and B and stores the result in A.
; B is pointed by R13, A is pointed by R12
PUBLIC mp_add   
RSEG CODE       

mp_add
    ADD  0x1e(R13),0x1e(R12)
    ADDC 0x1c(R13),0x1c(R12)
    ADDC 0x1a(R13),0x1a(R12)
    ADDC 0x18(R13),0x18(R12)
    ADDC 0x16(R13),0x16(R12)
    ADDC 0x14(R13),0x14(R12)
    ADDC 0x12(R13),0x12(R12)
    ADDC 0x10(R13),0x10(R12)
    ADDC 0xe(R13),0xe(R12)
    ADDC 0xc(R13),0xc(R12)
    ADDC 0xa(R13),0xa(R12)
    ADDC 0x8(R13),0x8(R12)
    ADDC 0x6(R13),0x6(R12)
    ADDC 0x4(R13),0x4(R12)
    ADDC 0x2(R13),0x2(R12)
    ADDC 0x0(R13),0x0(R12)
    
RETA
      
; Subtracts B from A where A and B are 256-bit numbers and stores the result in A.
; B is pointed by R13, A is pointed by R12
PUBLIC mp_sub   
RSEG CODE       

mp_sub
    SUB  0x1e(R13),0x1e(R12)
    SUBC 0x1c(R13),0x1c(R12)
    SUBC 0x1a(R13),0x1a(R12)
    SUBC 0x18(R13),0x18(R12)
    SUBC 0x16(R13),0x16(R12)
    SUBC 0x14(R13),0x14(R12)
    SUBC 0x12(R13),0x12(R12)
    SUBC 0x10(R13),0x10(R12)
    SUBC 0xe(R13),0xe(R12)
    SUBC 0xc(R13),0xc(R12)
    SUBC 0xa(R13),0xa(R12)
    SUBC 0x8(R13),0x8(R12)
    SUBC 0x6(R13),0x6(R12)
    SUBC 0x4(R13),0x4(R12)
    SUBC 0x2(R13),0x2(R12)
    SUBC 0x0(R13),0x0(R12)
    
RETA

; Shifts A left, i.e. multiplies by 2^16. The Most-Significant-Digit is lost.
; A is pointed by R12
PUBLIC mp_shiftl   
RSEG CODE      

mp_shiftl
    MOV 0x2(R12),0x0(R12)
    MOV 0x4(R12),0x2(R12)
    MOV 0x6(R12),0x4(R12)
    MOV 0x8(R12),0x6(R12)
    MOV 0xa(R12),0x8(R12)
    MOV 0xc(R12),0xa(R12)
    MOV 0xe(R12),0xc(R12)
    MOV 0x10(R12),0xe(R12)
    MOV 0x12(R12),0x10(R12)
    MOV 0x14(R12),0x12(R12)
    MOV 0x16(R12),0x14(R12)
    MOV 0x18(R12),0x16(R12)
    MOV 0x1a(R12),0x18(R12)
    MOV 0x1c(R12),0x1a(R12)
    MOV 0x1e(R12),0x1c(R12)
    MOV #0x0000,0x1e(R12)
    
RETA

; Shifts A right, i.e. divides by 2^16. The Least-Significant-Digit is lost.
; A is pointed by R12
PUBLIC mp_shiftr  
RSEG CODE      

mp_shiftr
    MOV 0x1c(R12),0x1e(R12)
    MOV 0x1a(R12),0x1c(R12)
    MOV 0x18(R12),0x1a(R12)
    MOV 0x16(R12),0x18(R12)
    MOV 0x14(R12),0x16(R12)
    MOV 0x12(R12),0x14(R12)
    MOV 0x10(R12),0x12(R12)
    MOV 0xe(R12),0x10(R12)
    MOV 0xc(R12),0xe(R12)
    MOV 0xa(R12),0xc(R12)
    MOV 0x8(R12),0xa(R12) 
    MOV 0x6(R12),0x8(R12)
    MOV 0x4(R12),0x6(R12)
    MOV 0x2(R12),0x4(R12)
    MOV 0x0(R12),0x2(R12)
    MOV #0x0000,0x0(R12)
    
RETA
    

; Multiplies B = 19*A. B has to be at least 272 bit long (= 17 words)
; A is pointed by R12, B is pointed by R13
PUBLIC mp_mul19
RSEG CODE

mp_mul19

    ; First multiply A by 16 and store it to B
    MOV 0x1(R12),0x0(R13)
    MOV 0x2(R12),0x2(R13)
    MOV 0x4(R12),0x4(R13)
    MOV 0x6(R12),0x6(R13)
    MOV 0x8(R12),0x8(R13)
    MOV 0xa(R12),0xa(R13)
    MOV 0xc(R12),0xc(R13)
    MOV 0xe(R12),0xe(R13)
    MOV 0x10(R12),0x10(R13)
    MOV 0x12(R12),0x12(R13)
    MOV 0x14(R12),0x14(R13)
    MOV 0x16(R12),0x16(R13)
    MOV 0x18(R12),0x18(R13)
    MOV 0x1a(R12),0x1a(R13)
    MOV 0x1c(R12),0x1c(R13)
    MOV 0x1e(R12),0x1e(R13)
    MOV #0x0000,0x20(R13)
    
    ; Add A to B two times
    ADD  0x1e(R12),0x1e(R13)
    ADDC 0x1c(R12),0x1c(R13)
    ADDC 0x1a(R12),0x1a(R13)
    ADDC 0x18(R12),0x18(R13)
    ADDC 0x16(R12),0x16(R13)
    ADDC 0x14(R12),0x14(R13)
    ADDC 0x12(R12),0x12(R13)
    ADDC 0x10(R12),0x10(R13)
    ADDC 0xe(R12),0xe(R13)
    ADDC 0xc(R12),0xc(R13)
    ADDC 0xa(R12),0xa(R13)
    ADDC 0x8(R12),0x8(R13)
    ADDC 0x6(R12),0x6(R13)
    ADDC 0x4(R12),0x4(R13)
    ADDC 0x2(R12),0x2(R13)
    ADDC 0x0(R12),0x0(R13)

RETA

; Computes the remainder after the division of A by B and stores the remainder in A.
; Assume that A >= B.
; B is pointed by R13, A is pointed by R12
PUBLIC mp_mod
RSEG CODE       

mp_mod

; Determine the difference of orders (number m). We find first non-zero digit in B: MSD -> LSD
; During this process also shift B to the left, so the order difference is compensated

CLR R4   
_findj  TST 0x0(R13)
        JNZ _pre
        INC R4
        MOV 0x2(R13),0x0(R13)
        MOV 0x4(R13),0x2(R13)
        MOV 0x6(R13),0x4(R13)
        MOV 0x8(R13),0x6(R13)
        MOV 0xa(R13),0x8(R13)
        MOV 0xc(R13),0xa(R13)
        MOV 0xe(R13),0xc(R13)
        MOV 0x10(R13),0xe(R13)
        MOV 0x12(R13),0x10(R13)
        MOV 0x14(R13),0x12(R13)
        MOV 0x16(R13),0x14(R13)
        MOV 0x18(R13),0x16(R13)
        MOV 0x1a(R13),0x18(R13)
        MOV 0x1c(R13),0x1a(R13)
        MOV 0x1e(R13),0x1c(R13)
        MOV #0x0000,0x1e(R13)
        JMP _findj

; Now B is shifted left, so that the MSDs of A and B have the same order.

; First we try to subtract A-beta^m*B

_pre    SUB  0x1e(R13),0x1e(R12)
        SUBC 0x1c(R13),0x1c(R12)
        SUBC 0x1a(R13),0x1a(R12)
        SUBC 0x18(R13),0x18(R12)
        SUBC 0x16(R13),0x16(R12)
        SUBC 0x14(R13),0x14(R12)
        SUBC 0x12(R13),0x12(R12)
        SUBC 0x10(R13),0x10(R12)
        SUBC 0xe(R13),0xe(R12)
        SUBC 0xc(R13),0xc(R12)
        SUBC 0xa(R13),0xa(R12)
        SUBC 0x8(R13),0x8(R12)
        SUBC 0x6(R13),0x6(R12)
        SUBC 0x4(R13),0x4(R12)
        SUBC 0x2(R13),0x2(R12)
        SUBC 0x0(R13),0x0(R12)
        
        JN _addb    ; If we got negative, add back
        JMP _div    ; Otherwise start division    
        
; This occurs whenever our assumption that A > beta^m*B was wrong
_addb   ADD  0x1e(R13),0x1e(R12)
        ADDC 0x1c(R13),0x1c(R12)
        ADDC 0x1a(R13),0x1a(R12)
        ADDC 0x18(R13),0x18(R12)
        ADDC 0x16(R13),0x16(R12)
        ADDC 0x14(R13),0x14(R12)
        ADDC 0x12(R13),0x12(R12)
        ADDC 0x10(R13),0x10(R12)
        ADDC 0xe(R13),0xe(R12)
        ADDC 0xc(R13),0xc(R12)
        ADDC 0xa(R13),0xa(R12)
        ADDC 0x8(R13),0x8(R12)
        ADDC 0x6(R13),0x6(R12)
        ADDC 0x4(R13),0x4(R12)
        ADDC 0x2(R13),0x2(R12)
        ADDC 0x0(R13),0x0(R12)

; Shift B one digit right (decrease the beta coefficient exponent j)
_div    MOV 0x1c(R13),0x1e(R13)
        MOV 0x1a(R13),0x1c(R13)
        MOV 0x18(R13),0x1a(R13)
        MOV 0x16(R13),0x18(R13)
        MOV 0x14(R13),0x16(R13)
        MOV 0x12(R13),0x14(R13)
        MOV 0x10(R13),0x12(R13)
        MOV 0xe(R13),0x10(R13)
        MOV 0xc(R13),0xe(R13)
        MOV 0xa(R13),0xc(R13)
        MOV 0x8(R13),0xa(R13)
        MOV 0x6(R13),0x8(R13)
        MOV 0x4(R13),0x6(R13)
        MOV 0x2(R13),0x4(R13)
        MOV 0x0(R13),0x2(R13)
        MOV #0x0000,0x0(R13)

; Subtract A - Beta^j*B, until we get negative
_sub    SUB  0x1e(R13),0x1e(R12)
        SUBC 0x1c(R13),0x1c(R12)
        SUBC 0x1a(R13),0x1a(R12)
        SUBC 0x18(R13),0x18(R12)
        SUBC 0x16(R13),0x16(R12)
        SUBC 0x14(R13),0x14(R12)
        SUBC 0x12(R13),0x12(R12)
        SUBC 0x10(R13),0x10(R12)
        SUBC 0xe(R13),0xe(R12)
        SUBC 0xc(R13),0xc(R12)
        SUBC 0xa(R13),0xa(R12)
        SUBC 0x8(R13),0x8(R12)
        SUBC 0x6(R13),0x6(R12)
        SUBC 0x4(R13),0x4(R12)
        SUBC 0x2(R13),0x2(R12)
        SUBC 0x0(R13),0x0(R12)
        JN _add     ; If we got negative, jump out
        JMP _sub    ; Otherwise continue subtracting
        
; Do a single addition to get positive
_add    ADD  0x1e(R13),0x1e(R12)
        ADDC 0x1c(R13),0x1c(R12)
        ADDC 0x1a(R13),0x1a(R12)
        ADDC 0x18(R13),0x18(R12)
        ADDC 0x16(R13),0x16(R12)
        ADDC 0x14(R13),0x14(R12)
        ADDC 0x12(R13),0x12(R12)
        ADDC 0x10(R13),0x10(R12)
        ADDC 0xe(R13),0xe(R12)
        ADDC 0xc(R13),0xc(R12)
        ADDC 0xa(R13),0xa(R12)
        ADDC 0x8(R13),0x8(R12)
        ADDC 0x6(R13),0x6(R12)
        ADDC 0x4(R13),0x4(R12)
        ADDC 0x2(R13),0x2(R12)
        ADDC 0x0(R13),0x0(R12)

; Now decrease R2 (the number of times B was shifted left)
DEC R4
JNZ _div

; Now A contains the proper remainder
RETA


; Computes the remainder after the division of A by B and stores the remainder in A.
; Assume that A >= B. 
; This is an extended version, which works with 272 bit number.
; B is pointed by R13, A is pointed by R12
PUBLIC mp_modex
RSEG CODE       

mp_modex

; Determine the difference of orders (number m). We find first non-zero digit in B: MSD -> LSD
; During this process also shift B to the left, so the order difference is compensated

CLR R4   
_2findj  TST 0x0(R13)
        JNZ _2pre
        INC R4
        MOV 0x2(R13),0x0(R13)
        MOV 0x4(R13),0x2(R13)
        MOV 0x6(R13),0x4(R13)
        MOV 0x8(R13),0x6(R13)
        MOV 0xa(R13),0x8(R13)
        MOV 0xc(R13),0xa(R13)
        MOV 0xe(R13),0xc(R13)
        MOV 0x10(R13),0xe(R13)
        MOV 0x12(R13),0x10(R13)
        MOV 0x14(R13),0x12(R13)
        MOV 0x16(R13),0x14(R13)
        MOV 0x18(R13),0x16(R13)
        MOV 0x1a(R13),0x18(R13)
        MOV 0x1c(R13),0x1a(R13)
        MOV 0x1e(R13),0x1c(R13)
        MOV 0x20(R13),0x1e(R13)
        MOV #0x0000,0x20(R13)
        JMP _2findj

; Now B is shifted left, so that the MSDs of A and B have the same order.

; First we try to subtract A-beta^m*B

_2pre    SUB  0x20(R13),0x20(R12)
        SUBC 0x1e(R13),0x1e(R12)
        SUBC 0x1c(R13),0x1c(R12)
        SUBC 0x1a(R13),0x1a(R12)
        SUBC 0x18(R13),0x18(R12)
        SUBC 0x16(R13),0x16(R12)
        SUBC 0x14(R13),0x14(R12)
        SUBC 0x12(R13),0x12(R12)
        SUBC 0x10(R13),0x10(R12)
        SUBC 0xe(R13),0xe(R12)
        SUBC 0xc(R13),0xc(R12)
        SUBC 0xa(R13),0xa(R12)
        SUBC 0x8(R13),0x8(R12)
        SUBC 0x6(R13),0x6(R12)
        SUBC 0x4(R13),0x4(R12)
        SUBC 0x2(R13),0x2(R12)
        SUBC 0x0(R13),0x0(R12)
        
        JN _2addb    ; If we got negative, add back
        JMP _2div    ; Otherwise start division    
        
; This occurs whenever our assumption that A > beta^m*B was wrong
_2addb   ADD  0x20(R13),0x20(R12)
        ADDC 0x1e(R13),0x1e(R12)
        ADDC 0x1c(R13),0x1c(R12)
        ADDC 0x1a(R13),0x1a(R12)
        ADDC 0x18(R13),0x18(R12)
        ADDC 0x16(R13),0x16(R12)
        ADDC 0x14(R13),0x14(R12)
        ADDC 0x12(R13),0x12(R12)
        ADDC 0x10(R13),0x10(R12)
        ADDC 0xe(R13),0xe(R12)
        ADDC 0xc(R13),0xc(R12)
        ADDC 0xa(R13),0xa(R12)
        ADDC 0x8(R13),0x8(R12)
        ADDC 0x6(R13),0x6(R12)
        ADDC 0x4(R13),0x4(R12)
        ADDC 0x2(R13),0x2(R12)
        ADDC 0x0(R13),0x0(R12)

; Shift B one digit right (decrease the beta coefficient exponent j)
_2div    MOV 0x1e(R13),0x20(R13)
        MOV 0x1c(R13),0x1e(R13)
        MOV 0x1a(R13),0x1c(R13)
        MOV 0x18(R13),0x1a(R13)
        MOV 0x16(R13),0x18(R13)
        MOV 0x14(R13),0x16(R13)
        MOV 0x12(R13),0x14(R13)
        MOV 0x10(R13),0x12(R13)
        MOV 0xe(R13),0x10(R13)
        MOV 0xc(R13),0xe(R13)
        MOV 0xa(R13),0xc(R13)
        MOV 0x8(R13),0xa(R13)
        MOV 0x6(R13),0x8(R13)
        MOV 0x4(R13),0x6(R13)
        MOV 0x2(R13),0x4(R13)
        MOV 0x0(R13),0x2(R13)
        MOV #0x0000,0x0(R13)

; Subtract A - Beta^j*B, until we get negative
_2sub    SUB  0x20(R13),0x20(R12)
        SUBC 0x1e(R13),0x1e(R12)
        SUBC 0x1c(R13),0x1c(R12)
        SUBC 0x1a(R13),0x1a(R12)
        SUBC 0x18(R13),0x18(R12)
        SUBC 0x16(R13),0x16(R12)
        SUBC 0x14(R13),0x14(R12)
        SUBC 0x12(R13),0x12(R12)
        SUBC 0x10(R13),0x10(R12)
        SUBC 0xe(R13),0xe(R12)
        SUBC 0xc(R13),0xc(R12)
        SUBC 0xa(R13),0xa(R12)
        SUBC 0x8(R13),0x8(R12)
        SUBC 0x6(R13),0x6(R12)
        SUBC 0x4(R13),0x4(R12)
        SUBC 0x2(R13),0x2(R12)
        SUBC 0x0(R13),0x0(R12)
        JN _2add     ; If we got negative, jump out
        JMP _2sub    ; Otherwise continue subtracting
        
; Do a single addition to get positive
_2add    ADD  0x20(R13),0x20(R12)
        ADDC 0x1e(R13),0x1e(R12)
        ADDC 0x1c(R13),0x1c(R12)
        ADDC 0x1a(R13),0x1a(R12)
        ADDC 0x18(R13),0x18(R12)
        ADDC 0x16(R13),0x16(R12)
        ADDC 0x14(R13),0x14(R12)
        ADDC 0x12(R13),0x12(R12)
        ADDC 0x10(R13),0x10(R12)
        ADDC 0xe(R13),0xe(R12)
        ADDC 0xc(R13),0xc(R12)
        ADDC 0xa(R13),0xa(R12)
        ADDC 0x8(R13),0x8(R12)
        ADDC 0x6(R13),0x6(R12)
        ADDC 0x4(R13),0x4(R12)
        ADDC 0x2(R13),0x2(R12)
        ADDC 0x0(R13),0x0(R12)

; Now decrease R2 (the number of times B was shifted left)
DEC R4
JNZ _2div

; Now A contains the proper remainder
RETA
  
END
