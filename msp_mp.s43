#include "msp430.h"
NAME msp_mp

; Reduces the number A modulo 2^255-19
; A is given by R12 and must be 512-bits (64 bytes) long in little-endian
PUBLIC mp_mod25519
RSEG CODE

mp_mod25519

  MOV R12,R4
  MOV R12,R5
  MOV #3,R7     ; In the worst-case scenario we need to reduce 3 times
  
  SUB #2,R4     ; Starting point
  ADD #32,R5    ; Upper pointer bound (beyond the MS word, additions by 2)
  
reduce_limbs
    INCD R4
    CMP R4,R5
    JZ limbs_done       ; If terminal address has been reached, go to round_done
    
    MOV 0x0(R4),&MPY    ; LSB of LS half
    MOV #0x01,&OP2      ; 1
    
    MOV 0x20(R4),&MAC   ; LSB of MS half 
    MOV #0x26,&OP2      ; 38
    
    MOV RESLO,0x0(R4)   ; Save S to LSB of LS half
    ADD RESHI,0x2(R4)   ; Add the carry to the second-LSB of the LS half
    
    CLR 0x20(R4)        ; We don't need this MS limb anymore
    JNC reduce_limbs    ; If no carry was created, proceed with the next digit
    
    MOV R4,R6           
    ADD #4,R6           ; Set R6 as the address after the processed words  
    
carry_prop              ; Now we need to propagate the carry
    SETC                ; Restore the carry bit
    ADC 0x0(R6)         ; Add the carry bit to where R6 points
    JNC reduce_limbs    ; If no more carry, step out
    INCD R6             ; Increment R6 by 2 
    JMP carry_prop      ; Otherwise, continue propagating
   
limbs_done  
    MOV R12,R4
    MOV R12,R5       
    ADD #2,R5           ; We lower the terminal address as we don't need to go further than 1 word  
    SUB #2,R4           ; Rewind R4
    DEC R7
    JNZ reduce_limbs    ; If we didn't reduce 3 times, continue  
    
RETA

PUBLIC mp_freeze
RSEG CODE

; Conditionally subtract 2^255-19 from the 255-bit number pointed by R12

mp_freeze
    
    MOV #0x7FFF,R4    
    XOR 0x1e(R12),R4    
    SUB #1,R4
    RRAM #4,R4         
    RRAM #4,R4
    RRAM #4,R4
    RRAM #3,R4          ; Set if the first limb is equal to 7FFF
    
    MOV R12,R10
    ADD #28,R10
compr
    MOV #0xFFFF,R5      
    XOR 0x0(R10),R5
    SUB #1,R5
    RRAM #4,R4         
    RRAM #4,R4
    RRAM #4,R4
    RRAM #3,R4    
    AND R5,R4           ; Set if any inner limbs are equal to FFFF
    DECD R10
    CMP #2,R10
    JNZ compr

    MOV #0xFFED,R5
    SUB 0x0(R12),R5
    RRAM #4,R4         
    RRAM #4,R4
    RRAM #4,R4
    RRAM #3,R4
    XOR #1,R5
    AND R5,R4           ; Set if the last limb is greater or equal to FFED
    
    ; Now subtract from the end
    MOV #0xFFED,R5
    AND R4,R5
    SUB R5,0x0(R12)
    SBC 0x2(R12)        ; If nothing was subtracted in the last step, there is no carry

    MOV R12,R10
    ADD #28,R10
insub
    MOV #0xFFFF,R5
    AND R4,R5
    SUB R5,0x0(R10)     ; Subtract from the inner limbs
    SBC 0x2(R10)        
    DECD R10
    CMP #2,R10
    JNZ insub

    MOV #0x7FFF,R5
    AND R4,R5
    SUB R5,0x1e(R12)

RETA


PUBLIC mp_cprop
RSEG CODE

; Propagates carry from address pointed by R10+2 until address given by R11 is reached (inclusive)
mp_cprop

  PUSH.W R8     ; Save R8
  PUSH.W R9     ; Save R9
  
  CLR R9        ; Clear R9
  ADC R9        ; Put the carry to R9
  MOV R8,R10    ; Put R10 to R8
cpg
  CMP R8,R11     ; Check if the last word was already processed
  JZ cpd         ; If yes, quit
  INCD R8        ; Move onto the next word
  
  ADD R9,0x0(R8) ; Add the carry to what R10 points to
  CLR R9         ; Clear R9
  ADC R9         ; Put the carry to R9
  JMP cpg
  
cpd
  TST R9        ; Check if there's still some carry in R9
  CLRC          ; Clear the carry flag after TST
  JZ cfin       ; If not just goto finish
  SETC          ; If yes, set the carry bit to allow further manual propagation
  
cfin
  POP.W R9      ; Restore R9
  POP.W R8      ; Restore R8
  
RETA

; Propagates the carry bit

PUBLIC mp_monrep25519
RSEG CODE

; Converts the given value to the Montgomery representation modulo 2^255-19
mp_monrep25519

  CLR R7
  MOV R12,R10
  MOV R12,R11
  ADD #31,R11   ; Set R11 to the last word
  
repmul
  CMP R10,R11   ; Check if we already processed the last word
  JZ repfin     ; If we did, finish multiplying

  MOV 0x0(R10),&MPY  ; Initialize the accumulator to what's at R10
  MOV #1,&OP2

  MOV 0x0(R10),&MAC  ; Multiply R10 by 19 and accumulate
  MOV #19,&OP2
  
  MOV RESLO,0x0(R10) ; Set the LS word to the lower word of the result 
  INCD R10           ; Move R10 to the next word
  ADD RESHI,0x0(R10) ; The carry in the higher word has to be added 
  CALLA #mp_cprop    ; Propagate the carry (starts from 4th word)
  ADC R7             ; Propagate possible overflow carry to R7
  JMP repmul
  
repfin    
  MOV 0x0(R12),&MPY    ; Put the LS word in the accumulator
  MOV #1,&OP2       
  
  MOV R7,&MAC          ; The overflow carry is in R7 
  MOV #0x26,&OP2       ; 38
    
  MOV RESLO,0x0(R12)   ; Save S to LSB of LS half
  
  MOV R12,R10
  INCD R10             ; Now we start propagating from R12+4 (mp_cprop adds 2) 
  
  ADD RESHI,0x0(R12)   ; Add the carry to second word and propagate
  CALLA #mp_cprop
  CALLA #mp_freeze
  
RETA

; B is pointed by R13, A is pointed by R12
; Result C is pointed by R14
PUBLIC mp_mulmod  
RSEG CODE       

mp_mulmod
  ; Finely Integrated Operand Scanning
  ; t[s] = R2, t[s+1] = R3, m = R4
  ; -------------------------------------- 

  ; For loop i = 0 .. s-1
  
  ; (C,S) = a[0]*b[i] + t[0]
  MOV #0x01,&MPY
  MOV 0x0(R14),OP2
  
  MOV 0x0(R12),&MAC
  MOV 0x0(R13),OP2
  
  ; t[1] += C
  INC R14
  ;CALLA mp_addc16
  DEC R14
  
  ; m = S*n[0]
  MOV RESLO,&MPY
  MOV #1234,OP2
    
RETA


; Adds two 256-bit numbers A and B and stores the result in A.
; B is pointed by R13, A is pointed by R12
PUBLIC mp_add   
RSEG CODE       

mp_add

    MOV R12,R4
    MOV R13,R5
    ADD #28,R4
    ADD #28,R5

    ADD  0x1e(R13),0x1e(R12) ; No need to CLRC in every step
cadd
    ADDC 0x0(R5),0x0(R4)
    DECD R5
    DECD R4
    CMP R4,R12
    JNZ cadd
    
RETA
      
; Subtracts B from A where A and B are 256-bit numbers and stores the result in A.
; B is pointed by R13, A is pointed by R12
PUBLIC mp_sub   
RSEG CODE       

mp_sub
  
    MOV R12,R4
    MOV R13,R5
    ADD #28,R4
    ADD #28,R5

    SUB  0x1e(R13),0x1e(R12) ; No need to CLRC in every step
csub
    SUBC 0x0(R5),0x0(R4)
    DECD R5
    DECD R4
    CMP R4,R12
    JNZ csub
    
RETA
  
END
