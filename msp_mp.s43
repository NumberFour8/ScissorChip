#include "msp430.h"
NAME msp_mp

PUBLIC mp_condsub
RSEG CODE

; Subtracts 2^255-19 from the number pointed by R12 if the R4 == 1
; otherwise subtracts nothing.

mp_condsub

    PUSH.W R5 
    PUSH.W R6
    PUSH.W R7  ; Save other used registers
    
    MOV R12,R6
    ADD #30,R6
    
    ; Need to precompute FFFF or 0 to R4
    MOV R4,R5
    CLR R4
    SUB R5,R4   ; R4 == 0 ? R4 = 0 : R4 = FFFF 

    ; Now subtract from the least significant limb
    MOV #0xFFED,R5      
    AND R4,R5
    
    SUB R5,0(R12)
    MOV SR,R7
    
    ; Subtract from the internal limbs
    MOV #0xFFFF,R5
    AND R4,R5
csubin
    SUBC R5,0(R12)
    MOV SR,R7
    INCD R12
    CMP R12,R6
    JZ csubfin
    MOV R7,SR
    JMP csubin
csubfin
    MOV #0x7FFF,R5
    AND R4,R5
    MOV R7,SR
    SUBC R5,0(R12)

    POP.W R7    ; Restore the registers
    POP.W R6
    POP.W R5
RETA

PUBLIC mp_condadd
RSEG CODE

; Adds 2^255-18 from the number pointed by R12 if the R4 == 1
; otherwise adds nothing.

mp_condadd

    PUSH.W R5 
    PUSH.W R6
    PUSH.W R7  ; Save other used registers
    
    MOV R12,R6
    ADD #30,R6
    
    ; Need to precompute FFFF or 0 to R4
    MOV R4,R5
    CLR R4
    SUB R5,R4   ; R4 == 0 ? R4 = 0 : R4 = FFFF 

    ; Now add to the least significant limb
    MOV #0xFFEE,R5      ; +1 for overflow
    AND R4,R5
    
    ADD R5,0(R12)
    MOV SR,R7
    
    ; Add to the internal limbs
    MOV #0xFFFF,R5
    AND R4,R5
caddin
    ADDC R5,0(R12)
    MOV SR,R7
    INCD R12
    CMP R12,R6
    JZ caddfin
    MOV R7,SR
    JMP caddin
caddfin
    MOV #0x7FFF,R5
    AND R4,R5
    MOV R7,SR
    ADDC R5,0(R12)

    POP.W R7    ; Restore the registers
    POP.W R6
    POP.W R5
RETA

PUBLIC mp_freeze
RSEG CODE

; Conditionally subtract 2^255-19 from the 255-bit number pointed by R12

mp_freeze

    CLR R4

; -- The following code does: R4 = (R12 > 2^255-19)
    MOV #0x7FFF,R5
    CMP 0x1e(R12),R5    
    BIS SR,R4
    
    MOV #0xFFFF,R7
    MOV R12,R10
    MOV R12,R6
    ADD #28,R10
    ADD #2,R6       ; R6 contains the stop address, the 2nd LS word
compr
    CMP @R10,R7      
    BIS SR,R4       
    
    DECD R10
    CMP R6,R10
    JNZ compr

    MOV #0xFFED,R5      ; Compare the last limb
    CMP @R12,R5
    BIS SR,R5
       
    AND #6,R4
    TST R4
    MOV SR,R4
    RRA R4
    XOR #1,R4
    AND #1,R4
    
    BIS R15,R4  ; Add the force bit
    
; -- 
    CALLA #mp_condsub

RETA

PUBLIC mp_cprop
RSEG CODE

; Propagates carry from address pointed by R10+2 until address given by R11 is reached (inclusive)
mp_cprop

  PUSH.W R8     ; Save R8
  PUSH.W R9     ; Save R9
  
  CLR R9        ; Clear R9
  ADC R9        ; Put the carry to R9
  MOV R10,R8    ; Put R10 to R8
cpg
  CMP R8,R11     ; Check if the last word was already processed
  JZ cpd         ; If yes, quit
  INCD R8        ; Move onto the next word
  
  ADD R9,0x0(R8) ; Add the carry to what R10 points to
  CLR R9         ; Clear R9
  ADC R9         ; Put the carry to R9
  JMP cpg
  
cpd
  CLRC
  BIS R9,SR     ; Restore the carry flag, if there was any
  
  POP.W R9      ; Restore R9
  POP.W R8      ; Restore R8
  
RETA

PUBLIC mp_monrep25519
RSEG CODE

; Converts the given value to the Montgomery representation modulo 2^255-19
; r = 2^256
mp_monrep25519

  PUSH.W R7
  PUSH.W R10
  PUSH.W R11    ; Save registers

  MOV R12,R10
  MOV R12,R11
  ADD #32,R11   ; Set R11 to the last word
  
  MOV #0,&MPY   ; Initialize accumulator
  MOV #0,&OP2
  
repmul
  CMP R10,R11   ; Check if we already processed the last word
  JZ repfin     ; If we did, finish multiplying

  MOV 0x0(R10),&MAC  ; Multiply digit by 38
  MOV #38,&OP2
 
  MOV RESLO,0x0(R10) ; Put lower word in the result 
  INCD R10           ; Move R10 to the next word
  
  MOV RESHI,&MPY     ; Put carry into the accumulator 
  MOV #1,&OP2
  
  JMP repmul
  
repfin    
  MOV RESLO,R7
  RLA R7
  MOV 0x1e(R12),R10
  AND #0x7FFF,0x1e(R12)
  RLA R10
  ADC R7               ; Add it to R7
  
  MOV 0x0(R12),&MPY    ; Put the LS word in the accumulator
  MOV #1,&OP2       
 
  MOV R7,&MAC          ; The overflow carry is in R7 
  MOV #19,&OP2         ; 19
    
  MOV RESLO,0x0(R12)   ; Save S to LSB of LS half
  MOV R12,R10
  INCD R10             ; Now we start propagating from R12+4 (mp_cprop adds 2) 
  ADD RESHI,0x0(R10)   ; Add the carry to second LS word and propagate
  CALLA #mp_cprop

  POP.W R11      ; Restore registers
  POP.W R10
  POP.W R7

RETA

PUBLIC mp_mulmod  
RSEG CODE       

; Performs modular multiplication of A and B which are both in Montgomery representation.
; The reduction is done modulo 2^255-19
; A is pointed by R12, B is pointed by R13.
; The result T has to be pointed by R14

mp_mulmod
  ; Finely Integrated Operand Scanning
  ; t[s] = R10, t[s+1] = R11, m = R4
  ; -------------------------------------- 
  CLR R10
  CLR R11

  ; For loop i = 0 .. s-1
  MOV R13,R7  ; Traverses B
  ADD #32,R7  ; Excluding sth word
outer_for

  ; (C,S) = t[0] + a[0]*b[i]
  MOV 0x0(R14),&MPY  ; t[0]
  MOV #1,&OP2        ; 1
  
  MOV 0x0(R12),&MAC  ; a[0]
  MOV 0x0(R13),&OP2  ; b[i]
  
  MOV RESLO,R5       ; Store S in R5
   
  ; ADD(t[1],C)
  PUSH.W R10 
  PUSH.W R11  ; Save R10 and R11
  
  MOV R14,R10        ; Put R14 to R10 which points to T
  INCD R10           ; Start adding carry after t[1]
  MOV R14,R11        
  ADD #30,R11        ; until (s-1)th word inclusive  
  ADD RESHI,0x0(R10)
  CALLA #mp_cprop    ; Propagate the carry (start at t[2])
  
  POP.W R11
  POP.W R10   ; Restore R10 and R11
  
  ADC R10     ; Propagate carry further to t[s]
  ADC R11     ; and to t[s+1]
  
  ; m = S*n'[0] mod 2^16
  MOV R5,&MPY        ; S
  MOV #0xCA1B,&OP2   ; n'[0]
  MOV RESLO,R4       ; Store m to R4
  
  ; (C,S) = S + m*n[0]
  MOV R5,&MPY           ; S
  MOV #1,&OP2           ; 1
  MOV R4,&MAC           ; m
  MOV #0xFFED,&OP2      ; n[0]
  
  ; For j = 1 .. s-2, last iteration is unrolled
  MOV R12,R8 
  INCD R8      ; a[j]
  MOV R12,R9    
  ADD #30,R9   ; a[s-1]
  MOV R14,R5
  INCD R5      ; t[j]
  MOV R14,R6   
  ADD #30,R6   ; t[s-1]
inner_for       
    
    MOV RESHI,R15
    
    ; (C,S) = t[j] + a[j]*b[i] + C
    MOV 0x0(R5),&MPY ; t[j]
    MOV #1,&OP2      ; 1
    
    MOV R15,&MAC   ; C
    MOV #1,&OP2      ; 1
    
    MOV 0x0(R8),&MAC  ; a[j]
    MOV 0x0(R13),&OP2 ; b[i] 
    
    ; ADD(t[j+1],C)
    PUSH.W R10
    PUSH.W R11  ; Save R10 and R11
    
    MOV R5,R10
    MOV R6,R11
    INCD R10
    ADD RESHI,0x0(R10)
    CALLA #mp_cprop  
    
    POP.W R11   
    POP.W R10   ; Restore R10 and R11
    
    ADC R10     ; Propagate carry further to t[s]
    ADC R11     ; and to t[s+1]
    
    ; (C,S) = S + m*n[j]
    MOV RESLO,&MPY      ; S
    MOV #1,&OP2         ; 1
    
    MOV R4,&MAC         ; m
    MOV #0xFFFF,&OP2    ; n[j] = 0xFFFF for j = 1 .. s-2
    
    ; t[j-1] = S
    MOV RESLO,-2(R5)
    
    INCD R8  ; Advance to a[++j]
    INCD R5  ; Advance to t[++j]
    CMP R8,R9 ; j = s-1 halts the loop
    JNZ inner_for
    
  ; The last iteration of the inner for is unrolled
  MOV RESHI,R15  
    
  ; (C,S) = t[s-1] + a[s-1]*b[i] + C
  MOV 0x0(R5),&MPY ; t[s-1]
  MOV #1,&OP2      ; 1
    
  MOV R15,&MAC   ; C
  MOV #1,&OP2      ; 1
    
  MOV 0x0(R8),&MAC  ; a[s-1]
  MOV 0x0(R13),&OP2 ; b[i] 
    
  ; ADD(t[s],C)
  ADD RESHI,R10
  ADC R11    ; Propagate carry to t[s+1]
    
  ; (C,S) = S + m*n[s-1]
  MOV RESLO,&MPY
  MOV #1,&OP2
    
  MOV R4,&MAC
  MOV #0x7FFF,&OP2
    
  ; t[s-2] = S
  MOV RESLO,-2(R5)
  
  ; Now the final post-processing
    
  ; (C,S) = t[s] + C
  MOV R10,R4      ; m is not needed anymore
  ADD RESHI,R4    ; Store S in R4
    
  MOV R4,0x0(R5)  ; t[s-1] = S
  MOV R11,R10     ; Store t[s+1] to t[s]
  ADC R10         ; t[s] = t[s+1] + C
  CLR R11         ; t[s+1] = 0
    
  INCD R13
  CMP R7,R13       ; Check if B traversal is still less than s
  JNZ outer_for
  
  MOV R14,R12      ; Move R12 to the result in R14
 ; CALLA #mp_freeze ; Conditionally subtract 2^255-19 in constant time
  
RETA

PUBLIC mp_mul2
RSEG CODE

; Multiplies number pointer by R12 by 2.

mp_mul2

  PUSH.W R4
  PUSH.W R5

  MOV R12,R5
  ADD #32,R5
  CLRC
rotl
  RLC 0(R12)
  MOV SR,R4
  INCD R12
  CMP R12,R5
  JZ finrot
  MOV R4,SR
  JMP rotl
finrot
  SUB #32,R12   ; Rewind R12
  AND #1,R4     ; Take just the carry flag
  CALLA #mp_condsub
  
  POP.W R5
  POP.W R4
RETA


; Adds two 256-bit numbers A and B and stores the result in A.
; B is pointed by R13, A is pointed by R12
PUBLIC mp_add   
RSEG CODE       

mp_add
  
    PUSH.W R4
    PUSH.W R5
    PUSH.W R10

    MOV R13,R10
    ADD #32,R10
    CLRC   ; Need to reset carry bit for the first SUBC to be equivalent to SUB
inadd
    ADDC @R13+,0(R12) 
    MOV SR,R5
    INCD R12
    CMP R13,R10
    JZ finadd
    MOV R5,SR
    JMP inadd
finadd   
    AND #1,R4      ; Extract only C flag
    SUB #32,R12    ; Rewind R12
    CALLA #mp_condsub
    
    POP.W R10
    POP.W R5
    POP.W R4
RETA
      
; Subtracts B from A where A and B are 256-bit numbers and stores the result in A.
; B is pointed by R13, A is pointed by R12
PUBLIC mp_sub   
RSEG CODE       
    
    PUSH.W R4
    PUSH.W R5
    PUSH.W R10

mp_sub
    CLR R4
    MOV R13,R10
    ADD #32,R10
    SETC   ; Need to set carry bit for the first SUBC to be equivalent to SUB
insub
    SUBC @R13+,0(R12) 
    BIS SR,R4
    MOV SR,R5
    INCD R12
    CMP R13,R10
    JZ finsub
    MOV R5,SR
    JMP insub
finsub
    AND #4,R4      ; Extract only N flag
    RRAM.W #2,R4   ; Shift it to the first position
    SUB #32,R12    ; Rewind R12
    CALLA #mp_condadd 

    POP.W R10
    POP.W R5
    POP.W R4

RETA
  
END
