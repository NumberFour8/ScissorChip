#include "msp430.h"
NAME msp_mp

PUBLIC mp_condsub
RSEG CODE

; Subtracts 2^255-19 from the number pointed by R12 if the LS bit of R4 is set
; otherwise subtracts nothing.
; If the second LS bit of R4 is set, addition is preformed instead of subtraction. 
mp_condsub
    
    PUSHM.W #5,R9 ; Save R5-R9 
    
    MOV R12,R6
    ADD #30,R6
    
    ; Depending on second bit of R4 we decide whether we subtract or add. This is constant time.
    BIT #2,R4
    JNZ setAdd
    MOV #0xFFED,R5
    MOV #0xFFFF,R8
    MOV #0x7FFF,R9
    JMP andLimbs
setAdd
    MOV #0x0011,R5
    MOV #0x0000,R8
    MOV #0x8000,R9
    JMP andLimbs
andLimbs
   
    ; Need to precompute FFFF or 0 to R4
    AND #1,R4
    MOV R4,R7
    CLR R4
    SUB R7,R4        ; R4 == 0 ? R4 = 0 : R4 = FFFF 

    ; Set or reset the limbs of 2^255-19
    AND R4,R5
    AND R4,R8
    AND R4,R9
    
    SUB R5,0(R12)    ; Subtract LS limb
    MOV SR,R7        ; Save SR
    INCD R12         ; Increase R12
    
    ; Subtract from the internal limbs
    MOV R7,SR
csubin
    SUBC R8,0(R12)
    MOV SR,R7
    INCD R12
    CMP R12,R6
    JZ csubfin
    MOV R7,SR
    JMP csubin
csubfin
    MOV R7,SR
    SUBC R9,0(R12)

    POPM.W #5,R9        ; Restore R5 - R10
RETA

PUBLIC mp_freeze
RSEG CODE

; Conditionally subtract 2^255-19 from the 255-bit number pointed by R12

mp_freeze
 
    CLR R4

; -- The following code does: R4 = (R12 > 2^255-19)
    MOV #0x7FFF,R5
    CMP 0x1e(R12),R5    
    BIS SR,R4
    
    MOV #0xFFFF,R5
    MOV R12,R10
    MOV R12,R6
    ADD #28,R10
    ADD #2,R6       ; R6 contains the stop address, the 2nd LS word
compr
    CMP @R10,R5      
    CLRC            ; Here we care only about equality
    BIS SR,R4       
    
    DECD R10
    CMP R6,R10
    JNZ compr

    MOV #0xFFED,R5      ; Compare the last limb
    CMP @R12,R5
    BIS SR,R4
    
    XOR #1,R4   ; Invert the carry bit
    BIT #3,R4
    MOV SR,R4   ; Carry bit is set if R4 is non-zero
    AND #1,R4   ; Extract carry bit
     
; -- 
    AND #0xFFFD,R4    ; Reset the second bit of R4 for subtraction
    CALLA #mp_condsub

RETA

PUBLIC mp_cprop
RSEG CODE

; Propagates carry from address pointed by R10+2 until address given by R11 is reached (inclusive)
mp_cprop

  PUSHM.W #2,R9     ; Save R8 and R9
  
  CLR R9        ; Clear R9
  ADC R9        ; Put the carry to R9
  MOV R10,R8    ; Put R10 to R8
cpg
  CMP R8,R11     ; Check if the last word was already processed
  JZ cpd         ; If yes, quit
  INCD R8        ; Move onto the next word
  
  ADD R9,0x0(R8) ; Add the carry to what R10 points to
  CLR R9         ; Clear R9
  ADC R9         ; Put the carry to R9
  JMP cpg
  
cpd
  CLRC
  BIS R9,SR     ; Restore the carry flag, if there was any
  
  POPM.W #2,R9      ; Restore R8 and R9
  
RETA

PUBLIC mp_monrep25519
RSEG CODE

; Converts the given value to the Montgomery representation modulo 2^255-19
; r = 2^256
mp_monrep25519

  PUSHM.W #3,R11 ; Save registers R9 - R11
  
  MOV R12,R10
  MOV R12,R11
  ADD #32,R11   ; Set R11 to the last word
  
  MOV #0,&MPY   ; Initialize accumulator
  MOV #0,&OP2
  
repmul
  CMP R10,R11   ; Check if we already processed the last word
  JZ repfin     ; If we did, finish multiplying

  MOV 0x0(R10),&MAC  ; Multiply digit by 38
  MOV #38,&OP2
 
  MOV RESLO,0x0(R10) ; Put lower word in the result 
  INCD R10           ; Move R10 to the next word
  
  MOV RESHI,&MPY     ; Put carry into the accumulator 
  MOV #1,&OP2
  
  JMP repmul
  
repfin    
  MOV RESLO,R9
  RLA R9
  MOV 0x1e(R12),R10
  AND #0x7FFF,0x1e(R12)
  RLA R10
  ADC R9               ; Add it to R9
  
  MOV 0x0(R12),&MPY    ; Put the LS word in the accumulator
  MOV #1,&OP2       
 
  MOV R9,&MAC          ; The overflow carry is in R9 
  MOV #19,&OP2         ; 19
    
  MOV RESLO,0x0(R12)   ; Save S to LSB of LS half
  MOV R12,R10
  INCD R10             ; Now we start propagating from R12+4 (mp_cprop adds 2) 
  ADD RESHI,0x0(R10)   ; Add the carry to second LS word and propagate
  CALLA #mp_cprop

  POPM.W #3,R11      ; Restore registers R9 - R11
  
RETA

PUBLIC mp_mul2
RSEG CODE

; Multiplies number pointer by R12 by 2.

mp_mul2

  PUSHM.W #2,R5 ; Save R4 and R5

  MOV R12,R5
  ADD #32,R5
  CLRC
rotl
  RLC 0(R12)
  MOV SR,R4
  INCD R12
  CMP R12,R5
  JZ finrot
  MOV R4,SR
  JMP rotl
finrot
  SUB #32,R12    ; Rewind R12
  AND #1,R4      ; Take just the carry flag, reset the second bit
  CALLA #mp_condsub
  
  POPM.W #2,R5  ; Restore R4 and R5
  
RETA

PUBLIC mp_add   
RSEG CODE       

; Adds two 256-bit numbers A and B and stores the result in C.
; B is pointed by R14, A is pointed by R13
; The result C is pointed by R12

mp_add
  
    PUSHM.W #3,R6       ; Save R4-R6
    
    MOV R14,R6
    ADD #32,R6
    CLRC   ; Need to reset carry bit for the first SUBC to be equivalent to SUB
inadd
    MOV @R13+,0(R12)
    ADDC @R14+,0(R12) 
    MOV SR,R5
    INCD R12
    CMP R14,R6
    JZ finadd
    MOV R5,SR
    JMP inadd
finadd   
    AND #1,R5      ; Extract only C flag, reset second bit for subtraction
    SUB #32,R12    ; Rewind R12
    CALLA #mp_condsub
    
    POPM.W #3,R6
RETA
      
PUBLIC mp_sub   
RSEG CODE       

; Subtracts B from A where A and B are 256-bit numbers and stores the result in C.
; B is pointed by R14, A is pointed by R13
; The result C is pointed by R12

mp_sub
    
    PUSHM.W #3,R6   ; Save R4 - R6
    
    CLR R4
    MOV R14,R6
    ADD #32,R6
    SETC           ; Need to set carry bit for the first SUBC to be equivalent to SUB
insub
    MOV @R13+,0(R12)
    SUBC @R14+,0(R12) 
    BIS SR,R4
    MOV SR,R5
    INCD R12
    CMP R14,R6
    JZ finsub
    MOV R5,SR
    JMP insub
finsub
    AND #4,R4      ; Extract only N flag
    RRAM.W #2,R4   ; Shift it to the first position
    SUB #32,R12    ; Rewind R12
    BIS #2,R4      ; Set the second bit of R4 for addition
    CALLA #mp_condsub

    POPM.W #3,R6   ; Restore R4 - R6
RETA
  
END
