#include "msp430.h"
NAME msp_mul32_sos

EXTERN mp_freeze

PUBLIC mp_mulmod32_sos
RSEG CODE

; Performs schoolbook multiplication of A and B.
; This function utilizes fully the 32-bit multiplier.
; A is pointed by R13, B is pointed by R14.
; The result T has to be pointed by R12 and at least 64 bytes long. R15 contains the size of B (in bytes).

mp_mulmod32_sos

  PUSHM.W #3,R7
  
  ; Separated Operand Scanning
  ; -------------------------------------- 

  ; For loop i = 0 .. s-1
  ; R15 contains size of B
  ADD R14,R15   ; Traverses B
  MOV R13,R6    ; Prepare the limit for A
  ADD #32,R6
outer_for4

  ; (C,S) = t[i] + a[0]*b[i]
  MOV @R12+,&MPY32L  ; t[i]
  MOV @R12+,&MPY32H
  MOV #1,&OP2L       ; 1
  MOV #0,&OP2H
    
  MOV 0x0(R13),&MAC32L  ; a[0]
  MOV 0x2(R13),&MAC32H
  MOV 0x0(R14),&OP2L    ; b[i] 
  MOV 0x2(R14),&OP2H

  ; t[i] = S
  MOV RES0,-4(R12)
  MOV RES1,-2(R12)

  MOV R13,R5  ; Traverses A
  ADD #4,R5
  MOV R12,R7  ; Traverses T starting at i+1
inner_for4
   
    ; (C,S) = t[i+j] + a[j]*b[i] + C
   MOV RES2,&MPY32L   ; C
   MOV RES3,&MPY32H      
   MOV #1,&OP2L       ; 1
   MOV #0,&OP2H
  
   MOV @R7+,&MAC32L   ; t[i+j]
   MOV @R7+,&MAC32H
   MOV #1,&OP2L       ; 1
   MOV #0,&OP2H
    
   MOV @R5+,&MAC32L   ; a[j]
   MOV @R5+,&MAC32H
   MOV 0x0(R14),&OP2L ; b[i] 
   MOV 0x2(R14),&OP2H

   ; t[i+j] = S
   MOV RES0,-4(R7)
   MOV RES1,-2(R7)
   
   CMP R5,R6
   JNZ inner_for4

  ; t[i+s] = C
  MOV RES2,0x0(R7)
  MOV RES3,0x2(R7)

  ADD #4,R14  ; b[++i]
  CMP R14,R15
  JNZ outer_for4

  POPM.W #3,R7
   
  ;CALLA #mp_mod25519

RETA

PUBLIC mp_mod25519
RSEG CODE

; Reduces the number A modulo 2^255-19
; A is given by R12 and must be 512-bits (64 bytes) long in little-endian.

mp_mod25519

  MOV R12,R4
  MOV R12,R5
  MOV #3,R7     ; In the worst-case scenario we need to reduce 3 times
  
  SUB #2,R4     ; Starting point
  ADD #32,R5    ; Upper pointer bound (beyond the MS word, additions by 2)
  
reduce_limbs
    INCD R4
    CMP R4,R5
    JZ limbs_done       ; If terminal address has been reached, go to round_done
    
    MOV @R4,&MPY    ; LSB of LS half
    MOV #0x01,&OP2      ; 1
    
    MOV 0x20(R4),&MAC   ; LSB of MS half 
    MOV #0x26,&OP2      ; 38
    
    MOV RESLO,0x0(R4)   ; Save S to LSB of LS half
    ADD RESHI,0x2(R4)   ; Add the carry to the second-LSB of the LS half
    
    CLR 0x20(R4)        ; We don't need this MS limb anymore
    JNC reduce_limbs    ; If no carry was created, proceed with the next digit
    
    MOV R4,R6           
    ADD #4,R6           ; Set R6 as the address after the processed words  
    
carry_prop              ; Now we need to propagate the carry
    SETC                ; Restore the carry bit
    ADC 0x0(R6)         ; Add the carry bit to where R6 points
    JNC reduce_limbs    ; If no more carry, step out
    INCD R6             ; Increment R6 by 2 
    JMP carry_prop      ; Otherwise, continue propagating
   
limbs_done  
    MOV R12,R4
    MOV R12,R5       
    ADD #2,R5           ; We lower the terminal address as we don't need to go further than 1 word  
    SUB #2,R4           ; Rewind R4
    DEC R7
    JNZ reduce_limbs    ; If we didn't reduce 3 times, continue  
    
    CALLA #mp_freeze
RETA

END